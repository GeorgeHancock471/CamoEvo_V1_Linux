

setOption("ShowRowNumbers", false);

//===========================================================================
//Get the File Path
//============================================================================

Dialog.create("Choose Directory");
		Dialog.addMessage("________________Choose Folder___________________");
		Dialog.addMessage("Select directory you would like your Generations to be stored.");
	Dialog.show();


imageDIR = getDirectory("Select folder you wish to use.");
configFilePath=imageDIR;
tempString = "select=["+ configFilePath+"]";
//print(configFilePath);


PopulationLocation = getDirectory("plugins") + "Tools/PopulationLocation.txt";

// SAVE PATH

dataFile = File.open(PopulationLocation);

	print(dataFile, imageDIR);

File.close(dataFile);

settingsFilePath = getDirectory("plugins") + "Tools/AlgorithmSettings.txt";

//===========================================================================
// Make file names easier to handle.
//============================================================================

csv = ".csv";
tif = ".tif";
txt = ".txt"'
png = ".png"

//==========================
// FUNCTIONS
//==========================
setOption("ShowRowNumbers", false);
setOption("ShowRowIndexes", false);


// TestPoint
//---------------------------------------------------
// Allows you to obtain the index of a Value within an Array.

function TestPoint(Title) {
Dialog.createNonBlocking("TestPoint");
Dialog.createNonBlocking("Did " + Title + " work?");
Dialog.show();

}


// Index
//---------------------------------------------------
// Allows you to obtain the index of a Value within an Array.

  function index(a, value) {
      for (i=0; i<a.length; i++)
          if (a[i]==value) return i;
      return -1;
  }

// Obtain SubArray
//---------------------------------------------------
// Allows you to obtain a SubArray of a given Name and Length, where a is the array and b is the original number of rows.

 function subArray(a, value, b) {
	IndexLab = index(a, value);
	Start = IndexLab + 1;
	End = IndexLab  + b;
	return Array.slice(a, Start, End);
}

// Obtain Table Names Array
//---------------------------------------------------
// Allows you to obtain an array of all the table column names

 function getColumnNames(name) {
	selectWindow(name);
	Table.showRowNumbers(false);
	name = Table.headings;
	name = split(name, "\t");
	Table.showRowNumbers(false);
	return name; 
}

// Obtain Row Length
//---------------------------------------------------
// Allows you to obtain the length of a row in a table.

 function getRowLength(name) {

	Nam = getColumnNames(name);
	strCol = Table.getColumn(Nam[0]);
	length = lengthOf (strCol);
	return length; 
}



//Table to Array
//--------------------------------------------------
// Converts a Table into a Super Array, dividing them by the column titles.

 function tableArrayConvert(TableName) {
	selectWindow(TableName);
	Table.showRowNumbers(false);
	ColNams = Table.headings;
	ColNams = split(ColNams, "\t");

	Tp = newArray();
	
	 for (i=0; i<ColNams.length; i++){

	Tm = ColNams[i];

	Tp2 = newArray(Tm);

	Tp3 = Table.getColumn(Tm);

	Tp = Array.concat(Tp, Tp2, Tp3);
	
	}
        	
	Table.showRowNumbers(false);
	return Tp;
	
	}

//Rotate Super Array
//--------------------------------------------------

function rotateSuperArray (a, Titles) {

	M1 = Titles[1];

	labelA = Titles[0];

	M3 =  index(a, M1)-1;
	
	b=Array.copy(a);

	for (i=0; i<Titles.length; i++){
		b = Array.deleteValue(b, Titles[i]);
	}

	arrTemp = newArray();

		for (i=0; i<M3; i++){

		arrTemp2 = newArray();
	
		for(j=0; j<Titles.length; j++){

		mod = i +(j*M3);

		arrTemp2 = Array.concat(arrTemp2, b[mod]);

			}

			labelB =labelA + i;
			labelC= newArray(labelB);

			arrTemp = Array.concat(arrTemp, arrTemp2);


			} 
	
	return arrTemp;
	
			}


//Reverse Rotate Super Array
//--------------------------------------------------

// Undoes the rotation of the super Array.

function rotateRevSuperArray (a, Titles, rowLength) {
	
		rowL= rowLength;
		
		titleL= Titles.length;
	
	//Array.show(a);

	arrTemp = newArray();

		for (i=1; i<titleL; i++){

		arrTemp2 = newArray("Nan");
	
		for(j=0; j<rowL; j++){

			mod = i +(j*(titleL));

			arrTemp2 = Array.concat(arrTemp2, a[mod]);

			}

			arrTemp2[0] = Titles[i];

			//Array.print(arrTemp2);

			arrTemp = Array.concat(arrTemp,arrTemp2);


			} 

	arrTemp3 = newArray();

	for (i=0; i<rowL; i++){

		Mult = i*(Titles.length);

		Nam = a[Mult];
		
		arrTemp3 = Array.concat(arrTemp3, Nam );

					}

	
	arrTemp3 = Array.concat(Titles[0], arrTemp3);

	arrTemp = Array.concat(arrTemp3, arrTemp);
	
	return arrTemp;
	
			}


//Rotate Table
//--------------------------------------------------

// Flips the axis of a Table.

function tableRotateVertical(TableOld, TableNew) {

	Table.create(TableNew);
	Table.showRowNumbers(false);

	arrRow = getColumnNames(TableOld);

	strCol = getRowLength(TableOld);

	outputArray = newArray(arrRow.length-1);

	for(j=0; j<strCol; j++){

	selectWindow(TableOld);

	for(k=1; k<arrRow.length; k++){
			T = k;
			CN = arrRow[T];
			outputArray[k-1] = getResult(CN, j);
		}

	selectWindow(TableNew);
	
	Label = arrRow[0] + "_" +  (j);

	Table.setColumn(Label, outputArray);

	}
	
	}


//Super Array to Table
//--------------------------------------------------
// Converts a Super Array back into a table using the Array of original titles.

function tableArrayRevert (TableName, a, Titles) {

	Table.create(TableName);
	Table.showRowNumbers(false);

	M1 = index(a, Titles[0]);

	M2 = index(a, Titles[1]);

	M3 = M2 - M1;

	for (i=0; i<Titles.length; i++){

	columnName = Titles[i];
	
	array = subArray(a, columnName, M3);

	Table.setColumn(columnName, array);

	}

}

//============================================================================
// Load Previous values
//============================================================================
settingsFilePath = imageDIR + "/AlgorithmSettings.txt";
if(File.exists(settingsFilePath) == 1){
	settingsString=File.openAsString(settingsFilePath);	// open txt data file
	defaultSettings=split(settingsString, "\n");
} else  defaultSettings = newArray(

"10",	// Number of Generations
"0.005",	// Offspring Mutation Rate
"0.005",	// T2 Mutation Rate

"poisson",	// Offspring Mutation Distri
"poisson",	// T2 Mutation Distri

"1",	// Offspring Mutation Str (uniform)
"1",	// T2 Mutation Str 

"2",	// Offspring Mutation Str (normal)
"2",	// T2 Mutation Str 

"6",	// Offspring Mutation Str (poisson)
"6",	// T2 Mutation Str 

"Two Point", // Crossover Settings

"24", // Population Size

"random", // Population Genotype

"Create Custom", // Use Existing Template

"random", // Mating System

"1/2", // Mating Pool

"1/3", // Deletion Pool	

"0", // Inversion Probability

"0", // Duplicate Probability

"none", // Crowd Operator

"2", // Crowd Operator Threshold

"4", // Crowd Number Removed

"offpsring" ); // mutation application


//===========================================================================
// Customise Algorithm Variables
//============================================================================

//-----------------------------------------------
// Choice Table New
//-----------------------------------------------

DeletionPool = newArray("none", "1/3", "1/2", "2/3", "all");

/*
Dialog.create("Pool Settings Part 1");

	
		Dialog.addMessage("_________________Deletion Pool____________________");
		Dialog.addMessage("The proportion of the population that gets removed with each generation");

		Dialog.addChoice("                                                        Deletion pool =", DeletionPool, defaultSettings[17]);


		Dialog.show();
*/


DeletionSize =  defaultSettings[17];

BreedShow=defaultSettings[16];
BreedingPool = newArray("none", "1/4", "1/2", "all");

if(DeletionSize=="all"){

DeleteMessage = "Breeding Pool = none, the original population gets cloned to make the new population\n\tBreeding Pool = 1/3, the top third of the original population get to breed thrice to make the new population\n\tBreeding Pool = 1/2, the top half of the original population get to breed twice to make the new population\n\tBreeding Pool = all, each individual from the original population gets to breed once to make the new population";
DeleteNum= 0;
CloneNum=1;
BreedingPool = newArray("none", "1/3", "1/2", "all");
if(index(BreedingPool, BreedShow)<0){
BreedShow="1/2";
}}


if(DeletionSize=="2/3"){

DeleteMessage = "Breeding Pool = none, the population gets cloned twice to refill the remaining population\n\tBreeding Pool = 1/4, the top third of the remaining population get to breed four times to refill the remaining population\n\tBreeding Pool = 1/2, the top half of the remaining population get to breed thrice to refill the remaining population\n\tBreeding Pool = all, each individual in the remaining population breeds twice to refill the remaining population";
DeleteNum= 2/3;
CloneNum=2;
}


if(DeletionSize=="1/2"){

DeleteMessage = "Breeding Pool = none, the population gets cloned to refill the remaining population\n\tBreeding Pool = 1/4, the top third of the remaining population get to breed thrice to refill the remaining population\n\tBreeding Pool = 1/2, the top half of the remaining population get to breed twice to refill the remaining population\n\tBreeding Pool = all, each individual in the remaining population breeds once to refill the remaining population";
DeleteNum= 1/2;
CloneNum=1;
}


if(DeletionSize=="1/3"){

DeleteMessage = "Breeding Pool = none, the top half of the population gets cloned to refill the remaining population\n\tBreeding Pool = 1/4, the top third of the remaining population get to breed twice to refill the remaining population\n\t Breeding Pool = 1/2, the top half of the remaining population get to breed once to refill the remaining population\n\tBreeding Pool = all, INVALID";
DeleteNum= 1/3;
CloneNum=1;
}


if(DeletionSize=="none"){

DeleteMessage = "None only, without deletion only clonal mutation is available.";
DeleteNum= 0;
CloneNum=2;

BreedShow="none";
BreedingPool = newArray("none");

}

/*
Dialog.create("Pool Settings Part 2");
	
		Dialog.addMessage("_________________Breeding Pool______________________");
		Dialog.addMessage("The proportion of the remaining population that gets to breed");
		Dialog.addMessage("NOTE altering these values will change the number of offspring produced by the Breeding pool.");
		Dialog.addMessage(DeleteMessage);
		
		Dialog.addChoice("                                                        Breeding pool =",BreedingPool, BreedShow);
	



		Dialog.show();
*/


BreedingSize = defaultSettings[16];

if(BreedingSize=="none"){
BreedNum =  0;
}

if(BreedingSize=="1/4"){
BreedNum =  1/4;
}

if(BreedingSize=="1/3"){
BreedNum =  1/3;
}

if(BreedingSize=="1/2"){
BreedNum =  1/2;
}

if(BreedingSize=="all"){
BreedNum =  1;
}

//-----------------------------------------------
// Choice Table1
//-----------------------------------------------
MutDistributions = newArray("uniform", "normal", "poisson");
/*
Dialog.create("Change Algorithim Settings Part 1");

		Dialog.addMessage("_________________Number of Generations_________________");
		Dialog.addMessage("The Number of Generations of Selection");
		Dialog.addNumber("                                                                              N Generations", defaultSettings[0]);
		
		Dialog.addMessage("____________________Mutation Rate______________________");
		Dialog.addMessage("Probability of a mutation occuring for each gene within the offspring of Tier 1");
		Dialog.addMessage("                                  (Tier 1 = the breeding population)");
		Dialog.addNumber("                                                        Offspring Mutation Rate", defaultSettings[1], 5, 6, "");

		Dialog.addMessage("Probability of a mutation occuring for each gene within Tier 2");
		
		Dialog.addMessage("                                  (Tier 2 = the non-breeding population)");
		Dialog.addNumber("                                                                  T2 Mutation Rate", defaultSettings[2], 5, 6, "");
		
		Dialog.addMessage("_________________Mutation Distribution____________________");
		Dialog.addMessage("The distribution of mutations that takes place for each gene. \n            uniform = +/- random()\n            normal = +/- random(gaussian)\n            poisson = +/- exp[random()]");

		Dialog.addChoice("                                                        Offspring Mutation Dist", MutDistributions, defaultSettings[3]);

		Dialog.addMessage("Probability of a mutation occuring within Tier 2");
		Dialog.addChoice("                                                                  T2 Mutation Dist",MutDistributions, defaultSettings[4]);

				
	Dialog.show();
*/
//-----------------------------------------------
// Choice Table1 Output
//----------------------------------------------------
numberGenerations =  defaultSettings[0];

mutRateOffs =  parseFloat(defaultSettings[1]);
mutRateT2 = parseFloat(defaultSettings[2]);

mutDistOffs =  defaultSettings[3];
mutDistT2 =  defaultSettings[4];
//----------------------------------------------------

//-----------------------------------------------
// Choice Table2
//-----------------------------------------------
crossTypes = newArray("random", "One Point", "Two Point");

Uniform = "Mutation Strength = random() / X,";
Normal = "Mutation Strength = random(gaussian)  / X,";
Poisson = "Mutation Strength = exp[random()] / X,"   ;

MutStrengMsg = newArray(Uniform, Normal, Poisson);

if(mutDistOffs == "uniform") {
Offs = 0;
OffSet = 5;
}
if(mutDistOffs == "normal") {
Offs = 1;
OffSet = 7;
}
if(mutDistOffs == "poisson") {
Offs = 2;
OffSet = 9;
}

if(mutDistT2 == "uniform") {
Tier2 = 0;
Tier2Set = 6;
}
if(mutDistT2 == "normal") {
Tier2 = 1;
Tier2Set = 8;
}
if(mutDistT2 == "poisson") {
Tier2 = 2;
Tier2Set = 10;
}

MatingSystemTypes = newArray ("random", "ranked", "poly", "disassortative", "assortative", "hancock", "adaptive");

/*
Dialog.create("Change Algorithim Settings Part 2");

		Dialog.addMessage("____________________Mutation Strength______________________");
		Dialog.addMessage("The strength of the mutation determines the range with which the gene can change.");
		Dialog.addMessage("Choose the Value of X for Offspring");
		Dialog.addNumber(MutStrengMsg[Offs]   +   "    X  =", defaultSettings[OffSet]);

		Dialog.addMessage("Choose the Value of X for T2");
		Dialog.addNumber(MutStrengMsg[Tier2]   +   "    X  =", defaultSettings[Tier2Set]);


		Dialog.addMessage("_____________________Cross Over Type______________________");
		Dialog.addMessage("Determines the pattern of recombination of genes between the parents.");
		Dialog.addMessage("        Random: all genes 50/50 (more variable)\n        One Point: one rand length segments (gene linkage)\n        Two Point: two rand length segments (gene linkage & more variance)");


		Dialog.addChoice("                                                                  Cross Over Type",crossTypes, defaultSettings[11]);


		
		Dialog.addMessage("____________________Mating System Type_____________________");
		Dialog.addMessage("Determines the pattern of mating between the T1 individuals (top 1/3rd of the population)");
		Dialog.addMessage("        Random: pairs are randomly selected\n        Ranked: pairs are selected by rank, with the top two mating together, then the next twp\n        Poly: the top 1/6 of T1 get to mate twice with random individuals\n        Disassortative: pairing of the most genotypically distant indviduals\n        Assortative: pairing of the most genotypically similar individuals");


		Dialog.addChoice("                                               Mating System Type",MatingSystemTypes, defaultSettings[15]);

                                                 		
	Dialog.show();
*/
Adaptive=0;
Hancock=0;
//-----------------------------------------------
// Choice Table2 Output
//----------------------------------------------------

mutStrengthOffs = parseFloat(defaultSettings[OffSet]);
mutStrengthT2 =  parseFloat(defaultSettings[Tier2Set]);

crossOver =defaultSettings[11];

if (crossOver == "random") 	{
crossSet1 = 0;
				} else { 
				crossSet1 = 1;		 
				}

if (crossOver == "Two Point") {
crossSet2 = 1;
				} else {
				crossSet2 = 0;                    
				}

MatingSystemChoice =  defaultSettings[15];

//----------------------------------------------------

mutStrengthOffs1 = defaultSettings[5];
mutStrengthOffs2 = defaultSettings[7];
mutStrengthOffs3 = defaultSettings[9];

mutStrengthT21 = defaultSettings[6];
mutStrengthT22 = defaultSettings[8];
mutStrengthT23 = defaultSettings[10];


if(mutDistOffs == "uniform") {
mutStrengthOffs1 = mutStrengthOffs;
}

if(mutDistOffs == "normal") {
mutStrengthOffs2 = mutStrengthOffs;
}

if(mutDistOffs == "poisson") {
mutStrengthOffs3 = mutStrengthOffs;
}



if(mutDistT2 == "uniform") {
mutStrengthT21 = mutStrengthT2;
}

if(mutDistT2 == "normal") {
mutStrengthT22 = mutStrengthT2;
}

if(mutDistT2 == "poisson") {
mutStrengthT23 = mutStrengthT2;
}



//-----------------------------------------------
// Choice Table Operators
//-----------------------------------------------

mutationOperatorArray=newArray("offpring", "T2", "both");
CrowdOperatorTypes=newArray("none", "random", "randomMate", "mutantRegion", "mutantMate");
/*
Dialog.create("Select Additional Opperators");

		Dialog.addMessage("_____________________Mutation Inversion______________________");
		Dialog.addMessage("Adds a probability of a random Inversion of a gene occuring");
		Dialog.addNumber("			Inversion Probability =", defaultSettings[18], 5, 6, "");

		Dialog.addMessage("____________________Mutation Duplication______________________");
		Dialog.addMessage("Adds a probability of a random duplication of a gene occuring replacing a gene near it");
		Dialog.addNumber("		      Duplication Probability =", defaultSettings[19], 5, 6, "");

		
		Dialog.addMessage("_________________________Apply to:______________________________");
		Dialog.addMessage("Applies the above mutation operators to T2");
		Dialog.addChoice("                    Application Choice =",mutationOperatorArray, defaultSettings[23]);

	
		Dialog.addMessage("______________________Crowd Operator________________________");
		Dialog.addMessage("Adds a pseudo immigration system if Genotype Difference becomes too low, removing set number of the least fit individuals and replacing them");
		Dialog.addMessage("\t none: no crowd operator is used.\t\n random: a new random individual is added.\t\n randomMate: a ghost individual is mated with the fittest individual.\t\n mutantRegion: a random section of the fittest indivuals genome undergoes duplication.\t\n mutantMate: the top individuals are mated with mutants of themselves(Requires Even number Removed)");
		Dialog.addChoice("                 Crowd Operator Choice =",CrowdOperatorTypes, defaultSettings[20]);
		Dialog.addNumber("		     Diversity threshold =", defaultSettings[21]);
		Dialog.addNumber("		      	  Number Removed =", defaultSettings[22], 0, 3, "");

                                                 		
Dialog.show();
*/
inversionRate =  defaultSettings[18];
duplicationRate =  defaultSettings[19];
applicationChoice = defaultSettings[23];

crowdOperator = defaultSettings[20];
crowdThreshold = parseFloat(defaultSettings[21]);
crowdNumber = parseFloat(defaultSettings[22]);


VoteMate = newArray();

GenLeng = numberGenerations;


settingsFilePath = getDirectory("plugins") + "Tools/PopulationLocation.txt";

if(File.exists(settingsFilePath) == 1){
	settingsString=File.openAsString(settingsFilePath);	// open txt data file
	defaultSettings=split(settingsString, "\n");
} 


CheckDirectory = defaultSettings[0];
GeneratList  =  getFileList(CheckDirectory);
GeneratArray = newArray();
GenSurvArray  = newArray();

for(i=0; i<GeneratList.length; i++) { // list all .txt files

	if(startsWith(GeneratList[i], "generation")==1 && endsWith(GeneratList[i], "_survival.txt")!=1){
		GeneratArray = Array.concat(GeneratArray, GeneratList[i]);
	}	

	if(endsWith(GeneratList[i], "_survival.txt")==1){
		GenSurvArray = Array.concat(GenSurvArray, GeneratList[i]);
	}											
		
}


if(GenSurvArray.length==GeneratArray.length){

ArrayLeng = lengthOf(GeneratArray);
A=ArrayLeng-1;

AI = parseInt(A);

if(AI>GenLeng){
print("All Generations Completed!");
}else{

GenNum = configFilePath + "generation_" + AI + txt;
GenNum2 = configFilePath + "generation_" + (AI+1) + txt;

GenName = "generation_" + AI + txt;
GenName2 = "generation_" + (AI+1) + txt;


setBatchMode(true);

// -------------------------------------------------------------------------------------------------------1) Array Generation -------------------------------------------------------------------------------------------------------

// This section loads up the pattern table and then creates a new table where the columns are the Pattern ID, as this helps for generating the genome arrays.

//====================================================================================================================================================



print("===================================");
print(" Array generation");
print("----------------------------------------------------------------");


// Pattern Tables
//------------------------------------------------------------------------------------------------------------------------------------------------

DAY = 86400;
INF =  30 * DAY * 1000;

for ( sv=0; sv<INF; sv++ ) { 


if(File.exists(GenNum) == 1)	{
					
					sv = INF;
					
					} else {
					
					wait (10);

					}

			}



oN = GenName;
gN = GenName2;
nPth = GenNum2;

//------------------------- Get the number of rows and columns-------------------------------------

// This is designed so that they can later be transformed into arrays.

// It also adds a check to make sure the population size is divisable by 6.


GenerationString=File.openAsString(GenNum);	// open txt data file
GenerationRows=split(GenerationString, "\n");

	Column_Titles = GenerationRows[0];
	CT=split(Column_Titles, "\t");
	F = lengthOf(CT);
	
VarLeng = GenerationRows.length-1;
lopLeng = VarLeng * DeleteNum;
lopLeng = VarLeng - lopLeng;

Genotype_IDs = newArray();
for(X=1; X<GenerationRows.length; X++){
Temp = split(GenerationRows[X], "\t");
Genotype_IDs = Array.concat(Genotype_IDs, Temp);
}





// -------------------------------------------------------------------------------------------------------2) Ranking by Fitness -------------------------------------------------------------------------------------------------------

// This section loads up the survival table from the same config path and then uses the results to help reorder the pattern IDs by their fitness value (the higher the value the greater the ranking.

//====================================================================================================================================================

print("===================================");
print(" Fitness Ranking");
print("----------------------------------------------------------------");


//------------------------------------------------------------------------------------------------------------------------------------------------
// Obtain Fitness Ranks
//================================================================================

configFilePath2 = replace(GenNum, txt, "_survival.csv");  // Opens Fitness Table

configFilePath2a = replace(GenNum, txt, "_survival.txt");  // Opens Fitness Table

DAY = 86400;
INF =  30 * DAY *1000;

for ( sv=0; sv<INF; sv++ ) { 

wait (10);

SurvivalPath1 = configFilePath2;

if(File.exists(SurvivalPath1) == 1)	{
					
					sv = INF;

					PathType="csv";

					survivalName = replace(GenName, txt, "_survival.csv");  // Opens Fitness Table
					
					}


SurvivalPath2 = configFilePath2a;


if(File.exists(SurvivalPath2) == 1)	{

					sv = INF;

					PathType="txt";

					survivalName = replace(GenName, txt, "_survival.txt");  // Opens Fitness Table
				

					}
}

print ("Survival Document has been Uploaded, Next Generation Creation, Commencing");

wait(10);


if(PathType == "csv"){

open( configFilePath2);

Table.rename(survivalName,"survival_table");  //-------------RENAME

selectWindow("survival_table"); 

Table.showRowNumbers(false);

T = Table.getColumn("fitness"); // Ranks Fitness
IDlabels = Table.getColumn("ID");

U = Array.rankPositions(T);

selectWindow("survival_table"); //-------------Cull the uneeded tables.
		run("Close");

}


if(PathType == "txt"){

SurvivalString = File.openAsString( configFilePath2a);
Rows = split(SurvivalString, "\n");

arrayFit = newArray();
arrayID = newArray();

for(X=1; X< Rows.length; X++){
row = split(Rows[X], "\t");

arrayID = Array.concat(arrayID, row[0]);
arrayFit = Array.concat(arrayFit, parseFloat(row[1]));
}

T = arrayFit ; // Ranks Fitness
IDlabels = arrayID;

U = Array.rankPositions(T);


}


//------------------------------------------------------------------------------------------------------------------------------------------------
// Get the current Highest ID number
//================================================================================

IDRanked = newArray();


IDmaxRank = -1;


//------------------------------------------------------------------------------------------------------------------------------------------------
// Create a Table of Ranks which removes the bottom third.
//================================================================================

Rank_Order = newArray();

	for(j=0; j<lopLeng; j++){

	Y = VarLeng -1 - j;

	X = U[Y];

	X = IDlabels[X];
	
	Label = X;

	X = subArray(Genotype_IDs, X, F);

	//Array.print(X);

	Rank_Order = Array.concat(Rank_Order, Label, X);

		}




SlicePoint=Rank_Order.length*BreedNum;

T3Array = newArray();
T1Array =  Array.slice ( Rank_Order, 0, (SlicePoint) );
T2Array =  Array.slice ( Rank_Order, (SlicePoint), Rank_Order.length);


if(BreedingSize=="none"){
T3Array=Array.copy(T2Array);
T1Array=newArray();

if(DeletionSize=="none"){
T2Array=newArray();
}
if(DeletionSize=="all"){
T3Array=newArray();
}
}

if(DeletionSize=="all"){
if(BreedingSize!="none"){
T2Array=newArray();
}}

//====================================================================================================================================================

// -------------------------------------------------------------------------------------------------------3) Mating Pool and Mating System ---------------------------------------------------------------------------------------------------------------------------------------------


// This section generates the mating pool by obtaining the array of column names and then pulling out the top 1/3rd.



//====================================================================================================================================================


print("===================================");
print(" Mating Pool and Mating System");
print("----------------------------------------------------------------");


VoteCrowd = newArray();

if(T1Array.length > 0){
//------------------------------------------------------------------------------------------------------------------------------------------------
// Calculate Population Pool.
//================================================================================

// This section generates the mating pool by coming up with top 1/3rd of the population.


// Get the list of Rank Titles and Number of Titles

CT2 = newArray();
F2 = 0;

for (i = 0 ; i < T1Array.length; i++){

if(startsWith(T1Array[i], "Gen")==1){
F2 = F2 + 1;
Nam = T1Array[i];

CT2= Array.concat(CT2, Nam);

} }


lopX = F2;

OffspringArray=newArray();
a_length =  subArray(Rank_Order, CT2[0], F);

a_length = lengthOf(a_length);


//------------------------------------------------------------------------------------------------------------------------------------------------
// Calculate How many breeding cycles need to take place.
//================================================================================

loppedAmount = VarLeng * DeleteNum;

if(lopX < loppedAmount){

mateCycle = loppedAmount/lopX;

mateCycleCheck = parseInt(mateCycle);
mateCycleCheck = mateCycleCheck-mateCycle;

if(mateCycleCheck != 0){
exit("You need to make sure that your population can be divided such that your mating system can repopulate correctly")
}

} else {


mateCycle = 1;

}

if(DeletionSize=="all"){
if(BreedingSize=="1/2"){
mateCycle = 2;
}
if(BreedingSize=="1/3"){
mateCycle = 3;
}
}


//------------------------------------------------------------------------------------------------------------------------------------------------
// Mating System
//================================================================================
RankComparison = newArray (a_length);
ALPHA=1.1;
BETA=1.9;
DELTA=crowdThreshold;



for(L=0; L<mateCycle; L++){

//-------------------
// Hancock
//-------------------
if(MatingSystemChoice == "hancock"){
Hancock = 1;
}

if(Hancock == 1){
n = lopX;

Q3 = (3/4)*(n+1);
Q3b = parseInt(Q3);
if (Q3 == Q3b){
Q3 = U[Q3];
} else{
Q3 = (U[Q3] + U[Q3-1])/2;
}


Q1 = (1/4)*(n+1);
Q1b = parseInt(Q3);
if (Q1 == Q1b){
Q1 = U[Q1];
} else{
Q1 = (U[Q1] + U[Q1-1])/2;
}

IQR = Math.sqrt(   Math.sqr(Q3-Q1)  );

OutlierT = (1.5*IQR) + Q3;

OutlierB = Q1 -(1.5*IQR);

TOP = VarLeng -1;
BOTTOM = VarLeng -loppedAmount;

MatingSystemChoice = "random";

if(U[TOP] > OutlierT){
MatingSystemChoice = "poly";
} 

if(U[BOTTOM] < OutlierB){
MatingSystemChoice = "poly";
} 



}




//-------------------
// Adaptive
//-------------------
if(MatingSystemChoice == "adaptive"){
Adaptive = 1;

if(AI<1){
MatingSystemChoice="assortative";
}else{

settingsFilePath = configFilePath + "AdaptationSettings.txt";
if(File.exists(settingsFilePath) == 1){
	settingsString=File.openAsString(settingsFilePath);	// open txt data file
	defaultSettings=split(settingsString, "\n");
	}
	
if(defaultSettings.length<1){
MatingSystemChoice="random";
}else{


defaultStart=defaultSettings.length-24;

check = defaultSettings[defaultStart-1];
if(startsWith(check, "generation") == 1){

defaultEnd=defaultSettings.length;
defaultSettings = Array.slice(defaultSettings, defaultStart, defaultEnd);

MatingSystemChoice = defaultSettings[15];

} else {

MatingSystemChoice = "random";

}

}
}
}

//-------------------
// Random Mating
//-------------------
if(MatingSystemChoice == "random"){

ParentSort = "NO";

PoolArray = newArray(lopX);

lopP = lengthOf(PoolArray);

	for(k=0; k<lopP; k++){  // create an array of random numbers

		//print ("k = " + k);
		PoolArray[k] = random();
		}


PoolArrayRank = Array.rankPositions(PoolArray);

}


//-------------------
// Ranked Mating
//-------------------
if(MatingSystemChoice == "ranked"){

ParentSort = "NO";

PoolArray = newArray(lopX);
lopP = lengthOf(PoolArray);

PoolArrayRank = Array.getSequence(lopX);
}


//-------------------
// Poly
//-------------------
if(MatingSystemChoice == "poly"){

ParentSort = "NO";

PoolArray = newArray(lopX);

lopP = lengthOf(PoolArray);

	for(k=0; k<lopP; k++){  // create an array of random numbers

		PoolArray[k] = random();
		}


PoolArrayRank = Array.rankPositions(PoolArray);

PoolArrayRankold = Array.copy(PoolArrayRank);
	//DELETE REPEATS
	
	temp2 = 0;

	for(k=0; k<lopP; k++){  // create an array of random numbers
		
		temp = k/6 - parseInt(k/6);

		if (temp == 0) {

		PoolArrayRank = Array.deleteValue(PoolArrayRank, temp2);
		
		temp2 = temp2 +1;
		} 
		}
	
	PoolArrayRankPrev = Array.copy(PoolArrayRank);

	lopPoly = lengthOf (PoolArrayRankPrev);

	PoolArrayRank = newArray();
	
		polNum = lopP - lopPoly;
	
		print ("Number of 'Poly Mating' individuals in the Mating Pool = " + polNum);
	
		PolyArray = Array.getSequence(polNum);

	
	// ADD POLY
	for(k=0; k<lopPoly; k++){  // create an array of random numbers

		Poly = parseInt(k/6.5);

		PoolArrayRank = Array.concat( PoolArrayRank, PolyArray [Poly], PoolArrayRankPrev [k] );

		


		
		}
	
}


//-------------------
// assortative
//-------------------
if(MatingSystemChoice ==  "assortative"){

Table.showRowNumbers(false);

	ParentSort = "YES";

	PoolArray = newArray(lopX);
	lopP = lengthOf(PoolArray);

	RankCompTitles = Array.copy(CT2);

	a_length =  subArray(Rank_Order, CT2[0], F);

	a_length = lengthOf(a_length);

	//Array.print(RankCompTitles);

	PoolArrayRank = newArray();


//POOL


for(g=0; g<lopP/2; g++){ // Set up pool of ranks that are still unused

	RankStandard=RankCompTitles[0];

	RankStandard = subArray(Rank_Order, RankStandard, F);

	//Array.show(RankStandard);

	Z_length = lengthOf(RankCompTitles);

	//Array.print(RankCompTitles);

	RankDifference=newArray(Z_length); 

	RankComparison = newArray (a_length);

	//print("Z_length = " + Z_length);

	// COLUMNS
		for(k=0; k<Z_length; k++){ // Go through Each Column
	
			RankComparing = RankCompTitles[k];
		
			RankComparing = subArray(Rank_Order, RankComparing, F);
	
			//Array.show(RankComparing);

	// GENE DISTANCE
		for (i = 0; i < a_length; i++){ // Calculate Distance

			RankSt = (RankStandard[i]);
			RankCo = (RankComparing[i]);
			
			NaNcheck=parseFloat(RankSt);
			NaNcheck=isNaN(NaNcheck);
			if(NaNcheck!=1){
			RankComparison[i] =     Math.sqrt(      Math.sqr ( RankSt - RankCo)      );      //measure of distance from optimum luminance
			}else{
			RankComparison[i]=0;
			}
			
			RankDiff = 0;

			for (f = 0; f <a_length; f++){

			RankDiff = (RankDiff + RankComparison[f]);
	
			RankDifference[k] =RankDiff;

					}

			
				}
			}

	RankedRankDifference = Array.rankPositions(RankDifference);

	DIF1=RankedRankDifference[0];
	DIF2=RankedRankDifference[1];
	
	PoolArrayRank = Array.concat(PoolArrayRank, RankCompTitles[DIF1], RankCompTitles[DIF2]);
	
	if (Z_length > 2){

	RankCompTitles = Array.deleteValue(RankCompTitles, RankCompTitles[DIF1]);
	
	
	DIF3 = DIF2 -1;
	
	RankCompTitles = Array.deleteValue(RankCompTitles, RankCompTitles[DIF3]);

			}

	}

	}



//-------------------
// Disassortative
//-------------------
if(MatingSystemChoice ==  "disassortative"){

Table.showRowNumbers(false);

	ParentSort = "YES";

	PoolArray = newArray(lopX);
	lopP = lengthOf(PoolArray);

	RankCompTitles = Array.copy(CT2);
	
	a_length =  subArray(Rank_Order, CT2[0], F);

	a_length = lengthOf(a_length);

	//Array.print(RankCompTitles);

	PoolArrayRank = newArray();


//POOL


for(g=0; g<lopP/2; g++){ // Set up pool of ranks that are still unused

	RankStandard=RankCompTitles[0];

	RankStandard = subArray(Rank_Order, RankStandard, F);

	//Array.show(RankStandard);

	Z_length = lengthOf(RankCompTitles);

	//Array.print(RankCompTitles);

	RankDifference=newArray(Z_length); 

	RankComparison = newArray (a_length);

	//print("Z_length = " + Z_length);

	// COLUMNS
		for(k=0; k<Z_length; k++){ // Go through Each Column
	
			RankComparing = RankCompTitles[k];
		
			RankComparing = subArray(Rank_Order, RankComparing, F);
	
			//Array.show(RankComparing);

	// GENE DISTANCE
		for (i = 0; i < a_length; i++){ // Calculate Distance

			RankSt = (RankStandard[i]);
			RankCo = (RankComparing[i]);
			
			NaNcheck=parseFloat(RankSt);
			NaNcheck=isNaN(NaNcheck);
			if(NaNcheck!=1){
			RankComparison[i] =     Math.sqrt(      Math.sqr ( RankSt - RankCo)      );      //measure of distance from optimum luminance
			}else{
			RankComparison[i]=0;
			}
			
			RankDiff = 0;

			for (f = 0; f <a_length; f++){

			RankDiff = (RankDiff + RankComparison[f]);

			RankDiff = 1 /  (RankDiff+1);
	
			RankDifference[k] =RankDiff;

					}

			
				}
			}

	RankDifference[0] = 0;

	RankedRankDifference = Array.rankPositions(RankDifference);

	DIF1=RankedRankDifference[0];
	DIF2=RankedRankDifference[1];
	
	PoolArrayRank = Array.concat(PoolArrayRank, RankCompTitles[DIF1], RankCompTitles[DIF2]);
	
	if (Z_length > 2){

	RankCompTitles = Array.deleteValue(RankCompTitles, RankCompTitles[DIF1]);
	
	
	DIF3 = DIF2 -1;
	
	RankCompTitles = Array.deleteValue(RankCompTitles, RankCompTitles[DIF3]);

			}

	}

	}





	
print ("Mating System = " + MatingSystemChoice);

//====================================================================================================================================================

// -------------------------------------------------------------------------------------------------------4) Crossover and Parent Selection---------------------------------------------------------------------------------------------------------

// Apologies that this section is such a behemoth. My inability to solve the issue  of not being able to make arrays of arrays and not being able to use ' X = Rank + i ' means I haven't quite cracked how to make this all 
// one loop function.

//====================================================================================================================================================

print("===================================");
print(" Crossover and Parent Selection");
print("----------------------------------------------------------------");

//------------------------------------------------------------------------------------------------------------------------------------------------
// --------------------------------------------------------------------Mating------------------------------------------------------------------
//================================================================================

PairNumCount = 0;

for(k=0; k<lopX; k++){

PairNumCount = PairNumCount + 1;

K = k;
k= k+1; //makes sure that k doubles each time.

//--------------------------------------------------------------------------------
// Get Parents
//=============================================

if (ParentSort == "YES"){

	p1 =  PoolArrayRank[K];

	p2 = PoolArrayRank[k];


	//Array.print(PoolArrayRank);

		} else {

	Num1 = PoolArrayRank[K];

	Num2 = PoolArrayRank[k];

	p1 = CT2[Num1];

	p2 = CT2[Num2];

	}

Parent1 = subArray(Rank_Order, p1, F);

Parent2 = subArray(Rank_Order, p2, F);

//Array.show(Parent1, Parent2);

print("----------------------------------------------------------------");
print("Mated Pair" + PairNumCount + " = " + p1 + " + " + p2);
print("----------------------------------------------------------------");
print("");

//if (ParentSort == "YES"){  //--------------------------Check Assortmant

checkDistanceArray1 = newArray(a_length);
checkDistanceArray2 = newArray(a_length);

RankStandard = Array.copy(Parent1);
RankComparing = Array.copy(Parent2);
			
	// GENE DISTANCE
		for (i = 0; i < a_length; i++){ // Calculate Distance

			RankSt = (RankStandard[i]);
			RankCo = (RankComparing[i]);
			
			
			NaNcheck=parseFloat(RankSt);
			NaNcheck=isNaN(NaNcheck);
			if(NaNcheck!=1){
			RankComparison[i] =     Math.sqrt(      Math.sqr ( RankSt - RankCo)      );      //measure of distance from optimum luminance
			}else{
			RankComparison[i]=0;
			}
			
			RankDiff = 0;

			for (f = 0; f <a_length; f++){

			RankDiff = (RankDiff + RankComparison[f]);
	
			CheckDist =RankDiff;

					}

					}

print("		Mated Pair Distance = " +  CheckDist );

//}


if (crossSet1==1) {

//--------------------------------------------------------------------------------
// Crossover One
//=============================================

a_length=lengthOf(Parent1); //  array length


crossPoint1= ( a_length*random() ); 	// random coordinate 1
crossPoint1= parseInt(crossPoint1);		 // convert to integer

crossPoint2= ( a_length*random() ); 	// random coordinate 2
crossPoint2= parseInt(crossPoint2);		 // convert to integer


crossArray1 = newArray(crossPoint1, crossPoint2);

crossArray1= Array.sort(crossArray1);

print ("		Cross Point 1 = " + crossArray1[0] + " Cross Point 2 =" + crossArray1[1]);

Crossover1 = Array.copy(Parent1);

Crossover2 = Array.copy(Parent2);


Y= crossArray1[0];
Z= crossArray1[1]+1;
	if (Z >=a_length){
		Z=a_length;
			}		

for(i=Y; i<Z; i++)	{
	Crossover1[i] = Parent2[i];
	Crossover2[i] = Parent1[i];
			}
	

	if (crossSet2==1) {
	//--------------------------------------------------------------------------------
	// Crossover Two
	//=============================================

	// Will Crossover be before or after previous.
	//-----------------------------------------------------------------------
	Bin=random();
	Bin =  parseInt(Bin);	

	if (Z==a_length-1) { // Make sure it can't be 1 if the prior array includes the First value in the array.
	Bin=0;
	}

	if (Y==0) { // Make sure it can't be 0 if the prior array includes the Final value in the array.
	Bin=1;
	}

	print("Bin =" + Bin);

	// Before
	//-----------------------------------------------------------------------
	if (Bin==0) { // If Bin =1, then it is after, if Bin = 0 it is before.

	b_length = crossArray1[0]-1 ; 	
	c_length = 0;

	// After
	//-----------------------------------------------------------------------
		} else {

	b_length = a_length - crossArray1[1]  - 1; // length from the longest to the last point
	c_length = crossArray1[1] + 1;
		}

	// Crossover
	//-----------------------------------------------------------------------

	crossPoint1= ( b_length*random() ); 	// random coordinate 1
	crossPoint1= parseInt(crossPoint1);		 // convert to integer
	crossPoint1= crossPoint1 + c_length;

	crossPoint2= ( b_length*random() ); 	// random coordinate 2
	crossPoint2= parseInt(crossPoint2);		 // convert to integer
	crossPoint2= crossPoint2 + c_length;

	crossArray2 = newArray(crossPoint1, crossPoint2);

	crossArray2= Array.sort(crossArray2);

	print ("		Cross Point 3 = " + crossArray2[0] + " Cross Point 4 =" + crossArray2[1]);

	Y= crossArray2[0];
	Z= crossArray2[1] +1;
	if (Z >=a_length){
	Z=a_length;
	}

	for(i=Y; i<Z; i++){
	Crossover1[i] = Parent2[i];	
	}

	for(i=Y; i<Z; i++){
	Crossover2[i] = Parent1[i];
	}

	} 


	} 


if (crossSet1==0) {

a_length=lengthOf(Parent1); //  array length

randGeneArray = newArray(a_length);
for(i=0; i<a_length; i++)	{
L = random();
L = parseInt(L);
Lprint = "Gene" + i + " = " + "Parent " + L;
print("		"+ Lprint);
randGeneArray [i] = L;	
				}

Crossover1 = Array.copy(Parent1);
Crossover2 = Array.copy(Parent2);

for(i=0; i<a_length; i++)	{
	L =  parseInt(i);
	if (randGeneArray[L] ==1){
	Crossover1[i] = Parent2[i];
	Crossover2[i] = Parent1[i];

				}
	

	}}


Offspring1 = Array.copy(Crossover1);

Offspring2 = Array.copy(Crossover2);

p1loc=Offspring1.length-2;
p2loc=Offspring1.length-1;

Offspring1[p1loc]="Par_"+p1;
Offspring1[p2loc]="Par_"+p2;
Offspring2[p1loc]="Par_"+p1;
Offspring2[p2loc]="Par_"+p2;
IDmaxRank = IDmaxRank+1;
label1 = "Gen" + (AI+1) + "_Mut0_ID" + IDmaxRank;

IDmaxRank = IDmaxRank+1;
label2 = "Gen" + (AI+1) + "_Mut0_ID"+ IDmaxRank;

//label1 =  p1 + " & " + p2; // These are used to make sure the mating is random (disabled)
//label2 =  p2 + " & " + p1;

OffspringArray = Array.concat (OffspringArray, label1, Offspring1, label2, Offspring2);



checkDistanceArray1 = newArray(a_length);
checkDistanceArray2 = newArray(a_length);

RankStandard = Array.copy(Parent1);
RankComparing = Array.copy(Offspring1);
			
	// GENE DISTANCE
		for (i = 0; i < a_length; i++){ // Calculate Distance

			RankSt = (RankStandard[i]);
			RankCo = (RankComparing[i]);
			
			NaNcheck=parseFloat(RankSt);
			NaNcheck=isNaN(NaNcheck);
			if(NaNcheck!=1){
			RankComparison[i] =     Math.sqrt(      Math.sqr ( RankSt - RankCo)      );      //measure of distance from optimum luminance
			}else{
			RankComparison[i]=0;
			}
			
			
			RankDiff = 0;

			for (f = 0; f <a_length; f++){

			RankDiff = (RankDiff + RankComparison[f]);
	
			CheckDist =RankDiff;

					}
				
					}

print("		Parent offspring Distance1 = " +  CheckDist );

VoteMate=Array.concat(VoteMate,"RAND");
VoteCrowd=Array.concat(VoteCrowd,"NO");

if(CheckDist<ALPHA){
VoteMate[VoteMate.length-1]="FAR";
}

if(CheckDist>BETA){
VoteMate[VoteMate.length-1]="NEAR";
} 

if(CheckDist<DELTA){
VoteCrowd[VoteCrowd.length-1]="YES";
}



RankStandard =  Array.copy(Parent2);
RankComparing = Array.copy(Offspring2);
			
	// GENE DISTANCE
		for (i = 0; i < a_length; i++){ // Calculate Distance

			RankSt = (RankStandard[i]);
			RankCo = (RankComparing[i]);
			
			NaNcheck=parseFloat(RankSt);
			NaNcheck=isNaN(NaNcheck);
			if(NaNcheck!=1){
			RankComparison[i] =     Math.sqrt(      Math.sqr ( RankSt - RankCo)      );      //measure of distance from optimum luminance
				}else{
			RankComparison[i]=0;
			}
			RankDiff = 0;

			for (f = 0; f <a_length; f++){

			RankDiff = (RankDiff + RankComparison[f]);
	
			CheckDist =RankDiff;

					}

					}

print("		Parent offspring Distance2 = " +  CheckDist );


VoteMate=Array.concat(VoteMate,"RAND");
VoteCrowd=Array.concat(VoteCrowd,"NO");

if(CheckDist<ALPHA){
VoteMate[VoteMate.length-1]="FAR";
}

if(CheckDist>BETA){
VoteMate[VoteMate.length-1]="NEAR";
} 

if(CheckDist>BETA){
VoteMate[VoteMate.length-1]="NEAR";
} 

if(CheckDist<DELTA){
VoteCrowd[VoteCrowd.length-1]="YES";
}




} }




//====================================================================================================================================================
// -------------------------------------------------------------------------------------------------------5) Genetic Mutation  -----------------------------------------------------------------------------------------------------------------------------

// This section provides genetic mutation which is important for increasing the range of phenotypes/genotypes explored.

// Only two groups within the population are mutated. The Offspring of Tier 1 and Tier 2. 

// The two groups mutate differently with Tier 2 having a higher probability of mutation than the Offspring.

// Again I don't have the know how to make this a loop instead for the same reasons as prior.

//====================================================================================================================================================

print("===================================");
print(" Mutations");
print("----------------------------------------------------------------");
print(",");
print(",");



lopO = lopX*mateCycle;

//-------------------------------------------------------------------a) Offspring Mutations--------------------------------------------------------------------


//===========================================================================================

print("Offspring  Mutations");
print("----------------------------------------------------------------");


CT3 = newArray();
F3 = 0;

for (i = 0 ; i < OffspringArray.length; i++){

if(startsWith(OffspringArray[i], "Gen")==1){
F3 = F3 + 1;
Nam = OffspringArray[i];

CT3= Array.concat(CT3, Nam);

} }


OffspringMutantArray = newArray();

for(k=0; k<F3; k++){

MutArray = newArray(a_length); //create the array

OffspringNum =  k;

OffspringNum = CT3 [OffspringNum];
label = OffspringNum;
						//print(OffspringNum);
OffspringNum =  subArray(OffspringArray, OffspringNum, F);

for(i=0; i<a_length-2; i++){

	//Gene = Array.slice(OffspringNum, i, i+1);
	
    	//Array.getStatistics(Gene, min);
		
	Gene= parseFloat(OffspringNum[i]);

	oGene = Gene;

	GeneNum = "Gene_" + i; // Used to test which gene it's on

	//print( GeneNum); // Used to display which gene it's on.
		//print("   min: "+min);

	

	// ==========MUTATION===========


	//-----------------Distribution & Strength---------------

	if (mutDistOffs == "uniform") {
		mutStr = random(); 
		mutStr = mutStr / mutStrengthOffs;  // modifies the mutation strength to give a lower probability of extreme mutations.
		prMut = "uniform";
	
	}

	if (mutDistOffs == "normal") {
		mutStr = random("gaussian"); 
		mutStr = mutStr / mutStrengthOffs;  // modifies the mutation strength to give a lower probability of extreme mutations.
		prMut = "normal";
	}
	
	if (mutDistOffs == "poisson") {
		mutStr = random(); 
		mutStr = exp(mutStr)/mutStrengthOffs;  // modifies the mutation strength to give a lower probability of extreme mutations.
		prMut = "poisson";
		
	}


	//-----------------Probability----------------------

		mutProb = random();
		if (mutProb<=mutRateOffs) {  // 
			mutat = 1;
		} else {
			mutat = 0;
		}
	if (mutat==1) { // All that follows only occurs if a mutation occurs.

		//-----------------Direction----------------------

		mutDir =  random();
		if (mutDir<=0.50) {
			mutDir = -1;
		} else {
			mutDir = 1;
		}

		//---------------Mutant Gene-------------------

		mutGene = oGene + (mutStr * mutDir); // the mutant gene is oGene =/- the random mutStr
			//-----Clipping------
			
			if (mutGene>1) { // Can't go above 1.
			mutGene = 1;
				}
			if (mutGene<0) { // Can't go below 0.
			mutGene = 0;
				}

		print ("                      		" + label + ","  + prMut + " Mutation, Gene " +  i  + " = " + oGene + " - > " + mutGene);
			
		} else {
		mutGene=oGene;

		
		print ("                      " +label + ","  + prMut + " Mutation, Gene " +  i  + " = No Mutation:"+mutGene);

		}


	// ==========INVERSION===========
	if(applicationChoice=="offspring"||applicationChoice=="both"){
	
	invProb = random();
		if (invProb<=inversionRate) {  // 
			invertG = 1;
		} else {
			invertG = 0;
		}


	if (invertG==1) {
	mutGene= 1-mutGene;

	print ("                      		" + label + ","  +  " Inversion, Gene " +  i  + " = " + 1-mutGene + " - > " + mutGene);
			    }else{
	
	print ("                      " +label + ","  +  " Inversion, Gene " +  i  + " = No Inversion :"+mutGene);

			}

	}

	MutArray[i] = mutGene;
		} 

	print ("");
	// ==========Duplication===========

	if(applicationChoice=="offspring"||applicationChoice=="both"){
	
	dupLeng=MutArray.length-2;
	for(DJ=0; DJ<dupLeng; DJ++){
	
	dupProb = random();
	if (dupProb<=duplicationRate) {  // 
			duplicateG = 1;
	} else {
			duplicateG = 0;
		}


	if (duplicateG==1) {
	DuplicatedGene=MutArray[DJ];
	IndexMult = Math.sqr( 1 - (1 / (dupLeng) ) );
	IndexAdd = exp(random())*IndexMult;
	IndexDir =  random();
		if (IndexDir<=0.50) {
			IndexDir = -1;
		} else {
			IndexDir = 1;
		}
	NewIndex = DJ + (IndexAdd*IndexDir);
	NewIndex = parseInt(NewIndex);
	
		if(NewIndex<0){
		NewIndex=(dupLeng-1)+NewIndex;
		}
		
		if(NewIndex>dupLeng-1){
		NewIndex= NewIndex-(dupLeng-1);
		}

	MutArray[NewIndex]=DuplicatedGene;
	print ("                      		" + label + ","  +  " Duplication, Gene " +  DJ  + " = " + "Index"+DJ + " - > " + "Index"+NewIndex);
	} 	
	}}

	p1loc=MutArray.length-2;
	p2loc=MutArray.length-1;
	
	p1=OffspringNum[p1loc];
	p2=OffspringNum[p2loc];

	MutArray[p1loc]=p1;
	MutArray[p2loc]=p2;
	
	
	OffspringMutantArray = Array.concat(OffspringMutantArray, label, MutArray);

}
} else {
OffspringMutantArray = newArray();
}


//-------------------------------------------------------------------b) Tier 2 Mutations--------------------------------------------------------------------
// Tier 2 = the middle third.
//===========================================================================================

if(T2Array.length > 0){

CT4 = newArray();
F4 = 0;

for (i = 0 ; i < T2Array.length; i++){

if(startsWith(T2Array[i], "Gen")==1){
F4 = F4 + 1;
Nam = T2Array[i];

CT4= Array.concat(CT4, Nam);

} }

a_length =  subArray(Rank_Order, CT4[0], F);
a_length = a_length.length;

T2MutantArray=newArray();

for(L=0; L<CloneNum; L++){

for(k=0; k<F4; k++){

MutArray = newArray(a_length); //create the array

RankNum = k;

RankNum = CT4 [RankNum];
label = RankNum;
labelSplit = split(label, "_");
mutNum = replace(labelSplit[1], "Mut", "");
mutNum = split(mutNum, ".");
mutNum = parseInt(mutNum[0]);
mutNum = mutNum+1;


if(BreedingSize=="none"){
if(L==0){
clone=".a";
}
if(L==1){
clone=".b";
}
}else{
clone="";
}

label = labelSplit[0]+"_Mut"+ mutNum + clone +"_"+labelSplit[2];
						//print(RankNum);
RankNum1 = subArray(T2Array, RankNum, F);

for(i=0; i<a_length; i++){

	Gene = Array.slice(RankNum1, i, i+1);
	
    	Array.getStatistics(Gene, min);

	oGene = min;

	GeneNum = "Gene_" + i; // Used to test which gene it's on

	//print( GeneNum); // Used to display which gene it's on.
		// print("   min: "+min);

	// ==========MUTATION===========


		//-----------------Distribution & Strength---------------

	if (mutDistT2 == "uniform") {
		mutStr = random(); 
		mutStr = mutStr / mutStrengthT2;  // modifies the mutation strength to give a lower probability of extreme mutations.
		prMut = "uniform";
	}

	if (mutDistT2 == "normal") {
		mutStr = random("gaussian"); 
		mutStr = mutStr / mutStrengthT2;  // modifies the mutation strength to give a lower probability of extreme mutations.
		prMut = "normal";
	}
	
	if (mutDistT2 == "poisson") {
		mutStr = random(); 
		mutStr = exp(mutStr)/mutStrengthT2;  // modifies the mutation strength to give a lower probability of extreme mutations.
		prMut = "poisson";
	}


	//-----------------Probability----------------------

		mutProb = random();
		if (mutProb<=mutRateT2) {  // This is the probability of a mutation occuring, it is intentionally high for the purposes of the demo.
			mutat = 1;
		} else {
			mutat = 0;
		}
	if (mutat==1) { // All that follows only occurs if a mutation occurs.

		//-----------------Direction----------------------

		mutDir =  random();
		if (mutDir<=0.50) {
			mutDir = -1;
		} else {
			mutDir = 1;
		}

		//---------------Mutant Gene-------------------

		mutGene = oGene + (mutStr * mutDir); // the mutant gene is oGene =/- the random mutStr

			//-----Clipping------
			
			if (mutGene>1) { // Can't go above 1.
			mutGene = 1;
				}
			if (mutGene<0) { // Can't go below 0.
			mutGene = 0;
				}

		print ("                      " + label + ","  + prMut + " Mutation, Gene " +  i  + " = " + oGene + " - > " + mutGene);
			
		} else {
		mutGene=oGene;

		print ("                      " +label + "," + prMut + " Mutation, Gene " +  i  + " = No Mutation:"+mutGene);

		}
	// ==========INVERSION===========
	if(applicationChoice=="T2"||applicationChoice=="both"){
	
	invProb = random();
		if (invProb<=inversionRate) {  // 
			invertG = 1;
		} else {
			invertG = 0;
		}


	if (invertG==1) {
	mutGene= 1-mutGene;

	print ("                      		" + label + ","  +  " Inversion, Gene " +  i  + " = " + 1-mutGene + " - > " + mutGene);
			    }else{
	
	print ("                      " +label + ","  +  " Inversion, Gene " +  i  + " = No Inversion:"+mutGene);

			}

	}

	MutArray[i] = mutGene;
		} 

	print ("");
	// ==========Duplication===========

	if(applicationChoice=="T2"||applicationChoice=="both"){
	
	dupLeng=MutArray.length-2;
	
	for(DJ=0; DJ<dupLeng; DJ++){
	
	dupProb = random();
	if (dupProb<=duplicationRate) {  // 
			duplicateG = 1;
	} else {
			duplicateG = 0;
		}


	if (duplicateG==1) {
	DuplicatedGene=MutArray[DJ];
	IndexMult = Math.sqr( 1 - (1 / (dupLeng) ) );
	IndexAdd = exp(random())*IndexMult;
	IndexDir =  random();
		if (IndexDir<=0.50) {
			IndexDir = -1;
		} else {
			IndexDir = 1;
		}
	NewIndex = DJ + (IndexAdd*IndexDir);
	NewIndex = parseInt(NewIndex);
	
		if(NewIndex<0){
		NewIndex=(dupLeng-1)+NewIndex;
		}
		
		if(NewIndex>dupLeng-1){
		NewIndex= NewIndex-(dupLeng-1);
		}

	MutArray[NewIndex]=DuplicatedGene;
	print ("                      		" + label + ","  +  " Duplication, Gene " +  DJ  + " = " + "Index"+DJ + " - > " + "Index"+NewIndex);
	} 	
	}}
	
	
	p1loc=MutArray.length-2;
	p2loc=MutArray.length-1;
	
	p1=RankNum1[p1loc];
	p2=RankNum1[p2loc];

	MutArray[p1loc]=p1;
	MutArray[p2loc]=p2;

T2MutantArray = Array.concat(T2MutantArray, label , MutArray); 

}}
} else {

T2MutantArray= newArray();

}


// -------------------------------------------------------------------------------------------------------6) Generation 2  -----------------------------------------------------------------------------------------------------------------------------

// This section generates the final table by converting the new Generation columns into rows within the same formatting as the original table.

//====================================================================================================================================================
//--------------------------------------Generation_New Array----------------------------------------
//==========================================================

if(DeletionSize=="all"){
T1Array=newArray();
}

//Array.show(OffspringMutantArray);



//--------------------------------------Crowd Operator----------------------------------------
//==========================================================

newCrowd=newArray();
if(crowdOperator!="none"){

NO = 0;
YES = 0;

for(R=0; R<VoteCrowd.length; R++){
if(VoteCrowd[R]=="YES"){
YES=YES+1;
}
if(VoteCrowd[R]=="NO"){
NO=NO+1;
}
}
if(NO>YES){
crowdThreshold=crowdThreshold+0.12;
}

if(YES>NO){
crowdThreshold=crowdThreshold-0.6;
if(T2MutantArray.length > 1){

RemoveCrowd=crowdNumber;
RemoveCrowd=parseInt(RemoveCrowd);
DeleteLength=F*RemoveCrowd;
for(l=0; l<DeleteLength; l++){
str=T2MutantArray.length-1;
T2MutantArray = Array.deleteIndex(T2MutantArray, str);
}

}

if(T2MutantArray.length < 1){
RemoveCrowd=crowdNumber;
RemoveCrowd=parseInt(RemoveCrowd);
DeleteLength=F*RemoveCrowd;
for(l=0; l<DeleteLength; l++){
str=T2MutantArray.length-1;
T1Array = Array.deleteIndex(T1Array, str);
}

}


newCrowd=newArray();

if(crowdOperator=="random"||crowdOperator=="randomMate"){
for(k=0; k<RemoveCrowd; k++){
crowdGenome=newArray(a_length);
for(i=0; i<a_length; i++){
if(i<a_length-2){
crowdGenome[i]=random();
}else{
crowdGenome[i]="X";
}}
label="Gen" + (AI+1) + "_Mut0_ID" + "X" + k;

if(crowdOperator=="randomMate"){

p1=CT2[k];
Parent1 = subArray(Rank_Order, p1, F);
Parent2 = crowdGenome;
randGeneArray = newArray(a_length);
for(i=0; i<a_length; i++)	{
L = random();
L = parseInt(L);
randGeneArray [i] = L;	
				}

Crossover1 = Array.copy(Parent1);
Crossover2 = Array.copy(Parent2);

for(i=0; i<a_length; i++)	{
	L =  parseInt(i);
	if (randGeneArray[L] ==1){
	Crossover1[i] = Parent2[i];
	Crossover2[i] = Parent1[i];

				}
	

	}

crowdGenome=Crossover1;
crowdGenome[crowdGenome.length-2]="Par_"+p1;
crowdGenome[crowdGenome.length-1]="Par_X";
}
newCrowd=Array.concat(newCrowd,label,crowdGenome);
}}


if(crowdOperator=="mutantRegion"){
for(k=0; k<RemoveCrowd; k++){
crowdGenome=subArray(Rank_Order, CT2[k], F);

region1=parseInt(random()*(F-1));
if(region1>=F-1){
region1=0;
}

region2=parseInt(random()*(F-1)/2)+region1;
if(region2>F-1){
region2=F-1;
}

for(i=region1; i<region2; i++)	{
	str=crowdGenome[i];
	val=parseFloat(str);
	mut=(random("gaussian")/4);
	crowdGenome[i]=val+mut;
		if (crowdGenome[i]>1) { // Can't go above 1.
			crowdGenome[i] = 1;
				}
			if (crowdGenome[i]<0) { // Can't go below 0.
			crowdGenome[i] = 0;
				}
	
				}

crowdGenome[crowdGenome.length-2]="Par_"+CT2[k];
crowdGenome[crowdGenome.length-1]="Par_X";
label="Gen" + (AI+1) + "_Mut0_ID" + "X" + k;
newCrowd=Array.concat(newCrowd,label,crowdGenome);
}
}
k1=0;

if(crowdOperator=="mutantMate"){
mutDir=1;
for(k=0; k<RemoveCrowd/2; k++){

crowdGenome=subArray(Rank_Order, CT2[k], F);

Parent1=subArray(Rank_Order, CT2[k], F);
Parent2=subArray(Rank_Order, CT2[k], F);


for(i=0; i<Parent2.length; i++){

mutDir =  random();
		if (mutDir<=0.50) {
			mutDir = -1;
		} else {
			mutDir = 1;
		}


val=Parent2[i];
val=parseFloat(val);

mod=YES-NO;
mod = exp(1+(1-mod));
mod = mod+3;

mut=exp(random())/6;


Parent2[i]=val+(mut*mutDir);

	if (Parent2[i]>1) { // Can't go above 1.
			Parent2[i] = 1;
				}
			if (Parent2[i]<0) { // Can't go below 0.
			Parent2[i] = 0;
				}
	


}


region1=parseInt(random()*(F-1));
if(region1>=F-1){
region1=0;
}

region2=parseInt(random()*(F-1)/1.5)+region1;
if(region2>F-1){
region2=F-1;
}

Offspring1=Array.copy(Parent1);
Offspring2=Array.copy(Parent2);

for(i=region1; i<region2; i++)	{
st1=Parent1[i];
st2=Parent2[i];
Offspring1[i] = st2;
Offspring2[i] = st1;	
				}
k1=k1+1;

label1="Gen" + (AI+1) + "_Mut0_ID" + "X" + k1;

k1=k1+1;

label2="Gen" + (AI+1) + "_Mut0_ID" + "X" + k1;

Offspring1[crowdGenome.length-2]="Par_"+CT2[k];
Offspring1[crowdGenome.length-1]="Par_X";

Offspring2[crowdGenome.length-2]="Par_"+CT2[k];
Offspring2[crowdGenome.length-1]="Par_X";

newCrowd=Array.concat(newCrowd,label1,Offspring1,label2,Offspring2);
}
}


}}

/*
Array.show(T1Array,T2Array, T2MutantArray, OffspringArray, OffspringMutantArray);
TestPoint("");
*/

Generation_New = Array.concat(T3Array, T1Array, T2MutantArray, newCrowd, OffspringMutantArray);

//--------------------------------------Reformat Next Gen----------------------------------------
//==========================================================

Titles = newArray();

for (i = 0 ; i < Generation_New.length; i++){

if(startsWith(Generation_New[i], "Gen")==1){
Nam = Generation_New[i];

Titles= Array.concat(Titles, Nam);

}

if(startsWith(Generation_New[i], "Gen")==1){
Nam = Generation_New[i];

Titles= Array.concat(Titles, Nam);

}

}

print("F  =  " +  F);

setBatchMode(false);




CT5 = newArray();
F5 = 0;

for (i = 0 ; i < Generation_New.length; i++){

if(startsWith(Generation_New[i], "Gen")==1){
F5 = F5 + 1;
Nam = Generation_New[i];

CT5= Array.concat(CT5, Nam);

} }

Generation_New2 = newArray();

for (i = 0; i < CT5.length; i++){
temp1 = subArray(Generation_New, CT5[i], F);
temp=newArray();
for(f=0; f<temp1.length;f++){
if(f<temp1.length-2){
str = d2s(temp1[f], 10);
}else{
str = temp1[f];
}
temp=Array.concat(temp, str);
}

temp = Array.concat(CT5[i], temp);
temp = String.join(temp,"\t");

Generation_New2 = Array.concat(Generation_New2, temp);

}

TitleNames = String.join(CT, "\t");

Generation_New2 = Array.concat(TitleNames,Generation_New2);


	dataFile = File.open(nPth);
	
	for(i=0; i<Generation_New2.length; i++){
	print(dataFile, Generation_New2[i]);
	}
	File.close(dataFile);

	


wait(10);

print(" ");
print(" ");

print (" Generation " + (A+1) + "= Finished");
print("<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<");



if(Adaptive == 1){

if(VoteMate.length < 1){
MatingSystemChoice = "assortative";
} else {
VoteMult = VoteMate.length/loppedAmount;
VoteCheck = VoteMult - parseInt(VoteMult);
if(VoteCheck == 0){
VoteStart= (VoteMult*loppedAmount)-loppedAmount;
VoteEnd=(VoteMult*loppedAmount);
VoteLast = Array.slice(VoteMate,VoteStart,VoteEnd);

RAND = 0;
NEAR = 0;
FAR = 0;

for(R=0; R<VoteLast.length; R++){
if(VoteLast[R]=="RAND"){
RAND=RAND+1;
}
if(VoteLast[R]=="NEAR"){
NEAR=RAND+1;
}
if(VoteLast[R]=="FAR"){
FAR=RAND+1;
}
}

MatingSystemChoice = "random";

if(NEAR>RAND){
if(NEAR>FAR){
MatingSystemChoice = "assortative";
}
}

if(FAR>RAND){
if(FAR>NEAR){
MatingSystemChoice = "disassortative";
}
}




}
}
}



settingsFilePath = configFilePath + "AdaptationSettings.txt";

// SAVE PREVIOUSLY USED SETTINGS
	File.append("\tgeneration_" + (AI+1), settingsFilePath);
	File.append(numberGenerations, settingsFilePath);
	File.append(d2s(mutRateOffs,10)    , settingsFilePath);
	File.append( d2s(mutRateT2,10)    , settingsFilePath);
	File.append( mutDistOffs    , settingsFilePath);
	File.append( mutDistT2    , settingsFilePath);
	File.append(  mutStrengthOffs1  , settingsFilePath);
	File.append( mutStrengthT21   , settingsFilePath);
	File.append( mutStrengthOffs2   , settingsFilePath);
	File.append(  mutStrengthT22   , settingsFilePath);
	File.append( mutStrengthOffs3    , settingsFilePath);
	File.append(  mutStrengthT23   , settingsFilePath);
	File.append( crossOver   , settingsFilePath);
	File.append(  "24"   , settingsFilePath);
	File.append( "random"   , settingsFilePath);
	File.append( "Create Custom"   , settingsFilePath);
	File.append( MatingSystemChoice   , settingsFilePath);
	File.append(  BreedingSize   , settingsFilePath);
	File.append( DeletionSize   , settingsFilePath);
	File.append( d2s(inversionRate,10)   , settingsFilePath);
	File.append( d2s(duplicationRate,10)   , settingsFilePath);
	File.append( crowdOperator   , settingsFilePath);
	File.append( crowdThreshold   , settingsFilePath);
	File.append( crowdNumber   , settingsFilePath);
	File.append( applicationChoice   , settingsFilePath);



}
}else{
print("waiting for survival data");
}

